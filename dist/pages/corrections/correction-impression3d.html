<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Correction détaillée de l'activité Impression 3D - TechnoDocs">
    <title>Correction Impression 3D | TechnoDocs</title>
    <link rel="stylesheet" href="/dist/css/style.css">
    <link rel="stylesheet" href="/dist/css/markdown.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;700&family=Fira+Code:wght@400;500&family=Lexend:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="header-placeholder"></div>

    <main>
        <article class="md-content" id="markdown-container">
            <div class="md-loading">Chargement de la correction...</div>
        </article>
    </main>

    <div id="footer-placeholder"></div>

    <!-- Marked.js en local (sécurité CSP) -->
    <script src="/dist/js/libs/marked.min.js"></script>

    <script type="module">
        import { loadComponents } from '/dist/js/components.js';

        // Charger header/footer
        loadComponents();

        // Configuration de Marked
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: true,
            mangle: false
        });

        /**
         * Injecte du HTML de manière sécurisée en utilisant DOMParser
         * @param {HTMLElement} container - L'élément cible
         * @param {string} htmlString - La chaîne HTML à injecter
         */
        const safeInjectHTML = (container, htmlString) => {
            if (!container) return;

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            container.textContent = '';
            Array.from(doc.body.childNodes).forEach(node => {
                container.appendChild(node.cloneNode(true));
            });
        };

        /**
         * Crée un message d'erreur de manière sécurisée
         * @param {string} message - Le message d'erreur
         * @returns {HTMLElement} - L'élément d'erreur
         */
        const createErrorMessage = (message) => {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'md-error';

            const strong = document.createElement('strong');
            strong.textContent = 'Erreur : ';

            const text = document.createTextNode(message);

            errorDiv.appendChild(strong);
            errorDiv.appendChild(text);

            return errorDiv;
        };

        /**
         * Génère une Table des Matières avec les Activités (h3) et Questions (h4)
         * @param {HTMLElement} container - Le conteneur avec le contenu Markdown
         */
        const generateTOC = (container) => {
            const h3Elements = container.querySelectorAll('h3');

            if (h3Elements.length === 0) return; // Pas d'activités, pas de TOC

            // Créer le conteneur de la TOC
            const tocContainer = document.createElement('nav');
            tocContainer.className = 'md-toc';
            tocContainer.setAttribute('aria-label', 'Table des matières');

            const tocTitle = document.createElement('div');
            tocTitle.className = 'md-toc-title';
            tocTitle.textContent = 'Table des matières';

            const tocList = document.createElement('ul');
            tocList.className = 'md-toc-list';

            h3Elements.forEach((h3, index) => {
                // Créer un ID unique pour le h3 s'il n'en a pas
                if (!h3.id) {
                    h3.id = `activite-${index + 1}`;
                }

                // Créer l'élément d'activité
                const activityItem = document.createElement('li');
                activityItem.className = 'md-toc-activity';

                const activityLink = document.createElement('a');
                activityLink.href = `#${h3.id}`;
                activityLink.textContent = h3.textContent;

                activityItem.appendChild(activityLink);

                // Trouver tous les h4 qui suivent ce h3 jusqu'au prochain h3
                const questions = [];
                let nextElement = h3.nextElementSibling;

                while (nextElement && nextElement.tagName !== 'H3') {
                    if (nextElement.tagName === 'H4') {
                        questions.push(nextElement);
                    }
                    nextElement = nextElement.nextElementSibling;
                }

                // Si des questions existent, créer une sous-liste
                if (questions.length > 0) {
                    const questionsList = document.createElement('ul');
                    questionsList.className = 'md-toc-questions';

                    questions.forEach((h4, qIndex) => {
                        // Créer un ID unique pour le h4 s'il n'en a pas
                        if (!h4.id) {
                            h4.id = `activite-${index + 1}-question-${qIndex + 1}`;
                        }

                        const questionItem = document.createElement('li');
                        const questionLink = document.createElement('a');
                        questionLink.href = `#${h4.id}`;
                        questionLink.textContent = h4.textContent;

                        questionItem.appendChild(questionLink);
                        questionsList.appendChild(questionItem);
                    });

                    activityItem.appendChild(questionsList);
                }

                tocList.appendChild(activityItem);
            });

            tocContainer.appendChild(tocTitle);
            tocContainer.appendChild(tocList);

            // Insérer la TOC après le premier h1 ou h2
            const firstHeading = container.querySelector('h1, h2');
            if (firstHeading && firstHeading.nextElementSibling) {
                firstHeading.parentNode.insertBefore(tocContainer, firstHeading.nextElementSibling);
            } else {
                container.insertBefore(tocContainer, container.firstChild);
            }
        };

        /**
         * Charge et affiche le fichier Markdown de correction
         */
        async function loadCorrection() {
            const container = document.getElementById('markdown-container');

            try {
                const response = await fetch('/dist/pages/content/md/correction-impression3d.md');

                if (!response.ok) {
                    throw new Error('Impossible de charger la correction');
                }

                const mdText = await response.text();
                const htmlContent = marked.parse(mdText);

                // Injection sécurisée via DOMParser (Zéro innerHTML)
                safeInjectHTML(container, htmlContent);

                // Générer la Table des Matières
                generateTOC(container);

                // Met à jour le titre avec le premier H1
                const firstH1 = container.querySelector('h1');
                if (firstH1) {
                    document.title = `${firstH1.textContent} | TechnoDocs`;
                }

            } catch (error) {
                container.textContent = '';
                container.appendChild(createErrorMessage(error.message));
                console.error('Erreur chargement correction:', error);
            }
        }

        // Charger automatiquement la correction
        loadCorrection();
    </script>
</body>
</html>
